commit 94bdc9785a1136cef6a982b042719783978e8a26
Author: Yuchung Cheng <ycheng@google.com>
Date:   Thu Jan 12 22:11:42 2017 -0800

    tcp: disable fack by default
    
    This patch disables FACK by default as RACK is the successor of FACK
    (inspired by the insights behind FACK).
    
    FACK[1] in Linux works as follows: a packet P is deemed lost,
    if packet Q of higher sequence is s/acked and P and Q are distant
    by at least dupthresh number of packets in sequence space.
    
    FACK is more aggressive than the IETF recommened recovery for SACK
    (RFC3517 A Conservative Selective Acknowledgment (SACK)-based Loss
     Recovery Algorithm for TCP), because a single SACK may trigger
    fast recovery. This obviously won't work well with reordering so
    FACK is dynamically disabled upon detecting reordering.
    
    RACK supersedes FACK by using time distance instead of sequence
    distance. On reordering, RACK waits for a quarter of RTT receiving
    a single SACK before starting recovery. (the timer can be made more
    adaptive in the future by measuring reordering distance in time,
    but currently RTT/4 seem to work well.) Once the recovery starts,
    RACK behaves almost like FACK because it reduces the reodering
    window to 1ms, so it fast retransmits quickly. In addition RACK
    can detect loss retransmission as it does not care about the packet
    sequences (being repeated or not), which is extremely useful when
    the connection is going through a traffic policer.
    
    Google server experiments indicate that disabling FACK after enabling
    RACK has negligible impact on the overall loss recovery performance
    with more reordering events detected.  But we still keep the FACK
    implementation for backup if RACK has bugs that needs to be disabled.
    
    [1] M. Mathis, J. Mahdavi, "Forward Acknowledgment: Refining
    TCP Congestion Control," In Proceedings of SIGCOMM '96, August 1996.
    
    Signed-off-by: Yuchung Cheng <ycheng@google.com>
    Signed-off-by: Neal Cardwell <ncardwell@google.com>
    Acked-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    
    [ANCLARK NOTE] 2025/05/04
    Tailored for QSDK Linux source tree 4.4.60.

diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
index 39ebc20ca1b2..1a34e9278c07 100644
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@ -79,7 +79,7 @@
 int sysctl_tcp_timestamps __read_mostly = 1;
 int sysctl_tcp_window_scaling __read_mostly = 1;
 int sysctl_tcp_sack __read_mostly = 1;
-int sysctl_tcp_fack __read_mostly = 1;
+int sysctl_tcp_fack __read_mostly;
 int sysctl_tcp_max_reordering __read_mostly = 300;
 int sysctl_tcp_dsack __read_mostly = 1;
 int sysctl_tcp_app_win __read_mostly = 31;
@@ -2072,7 +2072,8 @@ static bool tcp_pause_early_retransmit(struct sock *sk, int flag)
  *		Essentially, we have now two algorithms counting
  *		lost packets.
  *
- *		FACK: It is the simplest heuristics. As soon as we decided
+ *		FACK (Disabled by default. Subsumbed by RACK):
+ *		It is the simplest heuristics. As soon as we decided
  *		that something is lost, we decide that _all_ not SACKed
  *		packets until the most forward SACK are lost. I.e.
  *		lost_out = fackets_out - sacked_out and left_out = fackets_out.
